const domainConversion = {

	_publicSuffixes: [],

	stripDot: (domain) => {
		return (domain.indexOf(".") === 0) ? domain.substring(1) : domain;
	},

	readTextFileAsync: async (path) => {
		let response = await fetch(path, {mode:'same-origin'});
		let txt = await response.text();
		return txt;
	},

	readPublicSuffixesAsync: async () => {
		let txt = await domainConversion.readTextFileAsync(browser.extension.getURL("public_suffixes.txt"));
		domainConversion._publicSuffixes = [];
		let lines = txt.split("\n");
		for(let line of lines)
		{
			if (line.indexOf("//") != -1 || line.trim() == "") continue;
			let domain = line;
			if (line.indexOf("*") != -1) {
				// fix me
				let idx = line.indexOf("*.");
				domain = line.substring(idx + 2);
			} else
			if (line.indexOf("!") != -1) {
				continue;
			} 
			domainConversion._publicSuffixes.push(domain);
		}
	},

	stringInArray: (arr, search) => {
		return arr.find((str) => { return str.indexOf(search) === 0; });
	},

	hostnameToSld: (hostname) => {
		// return ip address
		let re = /\d*\.\d*\.\d*\.\d*$/;
		let matches = hostname.match(re);
		if (matches != undefined && matches[0] != undefined) return matches[0];
		// todo punycode
		// return 2nd level domain if it's not a public suffix
		re = /[a-z0-9-]*\.[a-z0-9-]{2,}$/;
		matches = hostname.match(re);
		if (matches != undefined && matches[0] != undefined) {
			if (!domainConversion.stringInArray(domainConversion._publicSuffixes, matches[0])) return matches[0];
		}
		// return hostname without www.
		if (hostname.indexOf("www.") === 0) return hostname.substring(4);
		// return full hostname
		return hostname;
	},

	urlStringToHostname: (url) => {
	  if (url.indexOf("http://") !== 0 && url.indexOf("https://") !== 0) return "none";
	  let a = document.createElement('a');
	  a.href = url;
	  return a.hostname;
	},

	urlStringToSld: (url) => {
		return domainConversion.hostnameToSld(domainConversion.urlStringToHostname(url));
	}
}

const cstoreList = {

	init: () => {
		cstoreList.populate();
		
	},

  populate: async () => {
		let cstores = [];
		let stores = await browser.cookies.getAllCookieStores();

	    for(let store of stores) cstores.push({name: store.id, id: store.id} );
	 
		if (browser.contextualIdentities)
		{
			let contexts = await browser.contextualIdentities.query({});
		 	for (let context of contexts) cstores.push({name: context.name, id: context.cookieStoreId});
		}
	},

}

const cookieTable = {

  _cookieData: [],
	_selectedStore: "firefox-default",
	displayInfosDomain: null,

	init: async () => {
		await cookieTable.populate();
		cstoreList.init();
		if (cookieTable.displayInfosDomain != null) 
		{
			//cookieTable.scrollDomainIntoView(cookieTable.displayInfosDomain);
			//cookieTable.displayCookiesForDomain(cookieTable.displayInfosDomain);
      console.log(cookieTable.displayInfosDomain);
		}
	},

  getStoreName: () => {
		return cookieTable._selectedStore;
	},

  populate: async () => {
		cookieTable._cookieData = await cookieTable.getCookieData(cookieTable._selectedStore);

		
	},

  getCookieForDomain: (domain, name) => {
		for (let d in cookieTable._cookieData)
		{
			for (let c of cookieTable._cookieData[d])
			{
				if (c.name == name && c.domain == domain) return c;
			}
		}
		return null;
	},

  getCookieData: async (cstore) => {
		let cookies = await browser.cookies.getAll({storeId: cstore});
		let cookie_data = [];
		for (let cookie of cookies)
		{
			let stripped_domain = domainConversion.hostnameToSld(domainConversion.stripDot(cookie.domain));
			if (cookie_data[stripped_domain] == undefined)
			{
				cookie_data[stripped_domain] = [cookie];
			} else {
				cookie_data[stripped_domain].push(cookie);
			}
		}
		return cookieTable.sortCookieData(cookie_data);
	},

	sortCookieData: (cookie_data) => {
		let keys = Object.keys(cookie_data);
		let tmp = [];
		keys.sort((a, b) => {
		  return a.localeCompare(b);
		});
		for (let k of keys) tmp[k] = cookie_data[k].slice();
		return tmp;
	}


}

const readGetParams = () => {
	let params = window.location.search.substr(1);
	if (params == "") return;
  console.log(params);
  console.log(params.indexOf("host="));
	if (params.indexOf("host=") != -1)
	{
		let host = params.substring(5);
		return host;
	}
	return false;
}

const init = async () => {
  console.log("come√ßando init");

	let domain = readGetParams();
  console.log(domain);
	if (domain !== false) {
    console.log("entrei no if");
		cookieTable.displayInfosDomain = domain;
	}

	await cookieTable.init();
	
	
}

	

